
    <div class="tab-pane" id="documentation">
        <div class="row">
            <!-- git hub button -->

        </div>

        <div class="row">
            <div class="col-sm-12">
                <p>

                The AW 2017/18 project was developed by Fábio Martins (fc48393), Joana Matos (fc50074), Rodrigo Matos (fc33451) and Sara Gonçalves (fc50254). The project consists in creating a semantic search engine for diseases and scientific articles, with the following components:

                </p>

                <ul>
                    <li><strong>Data Collection:</strong> collecting text and data about diseases (Demo I)</li>
                    <li><strong>Data Annotation: </strong> create semantic links between the collected data (Demo II)</li>
                    <li><strong>Data Access: </strong> make the information available as a web service and as dynamic web page</li>
                </ul>

                <p>
                This project was mainly developed using PHP Language and Python, and it can be divided in three main modules: data collection, data processing/calculation and data visualization.
                </p>
                <p>
                The first module (<i>DataCollector</i>) should be run separately by the command line using the php command. The <i>DataCollector</i> has two main functions: startCollection and updateCollection. These should be used when the data base is empty or it already has data stored, respectively. The data is stored in a relational database management systems that was designed specifically for this project. The model of this database can be found <a href="https://drive.google.com/open?id=1IqVnB0fHd2yJMDVukOVQzZ106gzLXCur">here</a>.
                </p>
                <p>
                The project architecture is based on a Model–view–controller (MVC) that is commonly used for developing user interfaces and divides an application into three interconnected parts. This is done to separate internal representations of information from the ways information is presented to and accepted from the user. The MVC design pattern decouples these major components allowing for efficient code reuse and parallel development.
                </p>
                <p>
                The second module (<i>DataProcessing or Inverted Index construction</i>) is composed of two Python scripts that should be run separately by the command line using the Python3 command. The first script (<i>invertedIndexCalculator.py</i>) calculates and saves in the database everything needed to build the inverted index for the collected documents (articles and tweets): the TF-IDF values (by using the MER tool) and the Similarity values (Resnik measure, by using the DiShIn tool). The second script (<i>invertedIndexBuilder.py</i>) takes that stored data and creates the ranks of articles and tweets per disease by using a relevance formula that takes into consideration the following components: the TF-IDF values, the Similarity values, implicit user feedback (the number of clicks in a given document), explicit user feedback (user relevance rating score) and document date of publishing. These ranks are also stored in the database after their calculation.
                </p>
                <p>
                <strong>Relevance formula</strong> = (rescaled TF-IDF value for the disease name in the document * 0.2) + (minimum rescaled Resnik Similarity value for the disease name in the document * 0.2) + (rescaled implicit user feedback (the number of clicks in a given document) * 0.2) + (rescaled explicit user feedback (user relevance rating score) * 0.3) + (rescaled document date of publishing * 0.1)
                </p>
                <p>
            </div>
        </div>

        <div class="row">
            <div class="col-sm-12">
                <h4> <b> Files Architecture </b> </h4>

                <p></p>
                <ul>
                    <li><h5>dataCollector </h5>
                        <ul>
                            <li> <b>dataCollector</b>: script that calls all API's (please see below) and retrieves the information </li>
                            <li> <b>startCollection</b>: script that starts the information gathering process when there is no data in the database (the first time)</li>
                            <li> <b>updateCollection</b>: script that updates information already stored in the database (subsequent times)</li>
                        </ul>
                    </li>

                    <li><h5>dataProcessing (scripts/annotation)</h5>
                        <ul>
                            <li> <b>calcUtils.py</b>: script for the calculation functions for the several components of the relevance formula </li>
                            <li> <b>dbUtils.py</b>: script for the database accessing functions </li>
                            <li> <b>DishinUtils.py</b>: script for the functions used to call DiShIn and output processing </li>
                            <li> <b>MERUtils.py</b>: script for the functions used to call MER and output processing </li>
                            <li> <b>invertedIndexCalculator.py</b>: script that calculates and saves in the database everything needed to build the inverted index for the collected documents (articles and tweets)</li>
                            <li> <b>invertedIndexBuilder.py</b>: script that takes that stored data and creates the ranks of articles and tweets per disease according to the relevance formula </li>
                        </ul>
                    </li>

                    <li><h5>public_html</h5>
                        <ul>
                            <li> <a href="/aw007" target="_BLANK">Home</a>: allows search by disease (with autocomplete) </li>
                            <li> <a href="diseases" target="_BLANK">Diseases</a>: displays diseases stored on database </li>
                            <li> <a href="statistics" target="_BLANK">Statistics</a>: displays statistics of the data stored on database </li>
                            <li> <a href="documentation" target="_BLANK">Documentation</a>: this document </li>
                        </ul>
                    </li>


                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-sm-12">
                <h4><b> API's Used for obtaining data</b></h4>

                <ul>
                <li><a href="http://dbpedia.org/sparql/"><strong>DBPedia</strong></a>: used to collect related metadata for each disease </li>

                <li><a href="https://developer.twitter.com/en/docs/api-reference-index"><strong>Twitter</strong></a>: used to collect related posts for each disease </li>

                <li><a href="https://www.flickr.com/services/api/"><strong>Flicker</strong></a>: used to collect related pictures for each disease </li>

                <li><a href="https://www.flickr.com/services/api/"><strong>PubMed</strong></a>: used to collect related articles for each disease </li>
                </ul>
            </div>

        </div>
        <div class="row">
            <div class="col-sm-12">
                <h4><b> External Resources</b></h4>

                <ul>
                <li> <a href="https://getbootstrap.com/docs/4.0/getting-started/introduction/"><strong>Bootstrap</strong></a>: Bootstrap is an open source toolkit for developing with HTML, CSS, and JS. It allows to quickly prototype ideas or build entire app with Sass variables and mixins, responsive grid system, extensive prebuilt components, and powerful plugins built on jQuery.</li>

                <li> <a href="https://twig.symfony.com/doc/2.x/intro.html"><strong>Twig</strong></a>: A designer and developer friendly by sticking to PHP's principles and adding functionality useful for templating environments. Twig compiles templates down to plain optimized PHP code. The overhead compared to regular PHP code was reduced to the very minimum. Twig has a sandbox mode to evaluate untrusted template code. This allows Twig to be used as a template language for applications where users may modify the template design. Twig is powered by a flexible lexer and parser. This allows the developer to define their own custom tags and filters, and to create their own DSL.</li>


                <li> <a href="https://mariadb.org/learn/"><strong>MariaDB</strong></a>: MariaDB Server is one of the most popular database servers in the world. It’s made by the original developers of MySQL and guaranteed to stay open source. MariaDB turns data into structured information in a wide array of applications, ranging from banking to websites. It is an enhanced, drop-in replacement for MySQL. MariaDB is used because it is fast, scalable and robust, with a rich ecosystem of storage engines, plugins and many other tools make it very versatile for a wide variety of use cases.</li>

                <li> <a href="http://www.chartjs.org"><strong>Chart.js</strong></a>: Simple yet flexible JavaScript charting for designers & developers.</li>

                <li> <a href="https://github.com/PyMySQL/PyMySQL"><strong>PyMySql</strong></a>: Pure-Python MySQL client library.</li>

                <li> <a href="https://github.com/lasigeBioTM/MER"><strong>MER</strong></a>: MER (Minimal Named-Entity Recognizer) is a Named-Entity Recognition tool which given any lexicon and any input text returns the list of terms recognized in the text, including their exact location (annotations). Given an ontology (owl file) MER is also able to link the entities to their classes.</li>

                <li> <a href="https://github.com/lasigeBioTM/DiShIn"><strong>DiShIn</strong></a>: DiShIn (Semantic Similarity Measures using Disjunctive Shared Information) is a software package that provides the basic functions to start using semantic similarity measures directly from a rdf or owl file.</li>

                </ul>
            </div>
        </div>
    </div>
